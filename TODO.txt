*** TODO ***

* Look through and make sure all the error-handling looks right; i.e.
  when connectivity with the remote host is lost, all the data structures
  and threads associated with the multi-socket are cleaned up
  and an error is returned to the caller.  Similarly, when physical 
  connections break, their CSockets and associated threads should be
  cleaned up.
  * Question: would it still make sense to keep a multi-socket around
    if there are no interfaces to connect on?  Presumably, if the other
    side keeps my listener port info, it could reconnect and THEN tell me
    about its interfaces.
    * Need to make sure that my code doesn't make any unnecessary
      assumptions that would make this difficult.

* Ensure that connections are gracefully cleaned up upon 
  close() or shutdown().

* Think about and write up a list of sensible ways to handle failures:
  * where all physical connections are broken, but interfaces
    are still available to connect on
  * where all physical connections are broken and no connections are possible

  * ALSO, think about this in terms of the following options for 
    failure notification:
    1) The application wants to ignore failure
    2) The application wants to be notified immediately
    3) The application wants to be notified after a timeout

* Make a more interesting test app with actual reordering and constraints.

* Make a regression test suite.

* Get rid of the scheduler threads and just have the sender worker thread
  and the application receiver thread make the scheduling decisions
  in a procedure call. (DONE)

* Think about the IROB data structure on the sender and receiver ends,
  especially how to index IROBs.

  * Useful indexes in the sender-side data structure:
    - Put simply, IROBs for which *some* bytes are ready to be sent 
      (whether those bytes are "begin/end" messages, or chunks, or acks).
    - Pending control messages (separate from IROBs).

  * Useful indexes in the receiver-side data structure:
    - IROBs that are ready to be received by the application.
    - IROBs/chunks that haven't been ACK'd.

* Rethink whether using TBB is a good idea.

* Try the throughput experiment with induced latency on a vanilla socket,
  to see whether latency is causing throughput degradation.
  * Prelim: doesn't seem to affect throughput significantly (4ms or 30ms 
    NISTnet latency, comparable to/more than the per-send latency I was
    inducing.)

* This reasonable assumption makes implementation simpler:
   "IROBs may not depend on future IROBs.  Thus, the IROB IDs form
    a partial order over all IROBs."  (DONE; implemented the IROB
       data structure as a std::deque wraapper)

* XXX IMPORTANT!!!: make sure that recv doesn't return 0 prematurely.

* Get rid of recv_labels for cmm_send and the like.  A label applies to
  a connection, not an interface.  This has implications which will 
  play out later, but for now, getting rid of the recv_labels simplifies
  the interface.
