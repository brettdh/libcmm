Internals of the multi-socket library
-------------------------------------

The multi-socket data structure
-------------------------------

The internal multi-socket data structure has these data elements:
 - An integer socket file descriptor
 - All information needed to create new sockets as needed, including:
   - Parameters for the socket() system call (PF_INET, SOCK_STREAM, etc)
   - All socket options set on this multisocket

 - An internal listener socket and a listener thread that accepts
    new physical connections inside the multi-socket
 - The set of available local network interfaces and their labels
 - The set of available remote network interfaces and their labels
 - The remote multi-socket's internal listener port, for initiating
    new physical connections
 (The above information is exchanged with the initial multi-socket
  post-connection handshake and may be updated later with control
  messages as conditions change on either end.)

 - A CMMSocketSender structure, which contains:
    - IROB information for all IROBs in flight but not yet ACK'd,
      including copied data buffers and dependency information
    - A collection of application thread identifiers, indicating
      application threads blocking on sending actions.
    - A thread that receives requests from other parts of the
      library, including application actions and messages from
      the scout, and dispatches network messages to worker threads

 - A CMMSocketReceiver structure, which contains:
    - IROB information for IROBs that have been received by the
      library but not yet passed to the application, including
      copied data buffers and dependency information
    - A collection of "released" IROBs - IROBs that have no unmet
      dependencies and are ready to be passed to the application
    - A thread that receives messages from worker threads and
      performs some action based on their contents. Such actions
      include adding IROBs to the collection, adding chunks to
      existing IROBs, updating the available interface information,
      and gracefully terminating a multisocket connection.

 - A CSockMapping structure, which provides an abstract way to
   create and lookup physical connections by label-matching.
   Behind this abstraction, the mapping may change based on 
   updates from the scout, or internally to implement (e.g.) traffic 
   striping and defaulting to the "best" interface if one exists.
 - Each physical connection has these components:
    - A connected socket file descriptor
    - A local/remote interface pair, with associated labels
       - Note to self: this needs to be made more resilient to 
         changing interfaces and labels
    - A sender-worker thread, which receives requests from the 
      CMMSocketSender thread and sends them on its socket
    - A receiver-worker thread, which receives messages from the
      network and passes them to the multisocket's CMMSocketReceiver

IROB data structures
--------------------

At both the sender and receiver, an IROB contains:
 - An integer ID
 - Send labels and recv labels
 - A collection of dependencies (IROB IDs)
 - A collection of dependents (IROB IDs)
 - A list of data chunks
 - A flag indicating whether the IROB is "default" (no explicit dependencies,
    but depends on all previous IROBs)
 - A flag indicating whether all the application data for this IROB has
    been sent/received

At the sender, IROBs also contain:
 - A thunk handler function and argument, optionally
 - Per-byte and per-IROB acknowledgement status

At the receiver, IROBs also contain:
 - Bookkeeping information about bytes that have been passed to the application

(...under construction...)

Threads and their interactions
------------------------------

Recapping from above, for each multi-socket, the library creates these threads:
  * An internal listener thread, which accepts new connections
    and adds them to the multi-socket.
  * A sender-scheduler thread, which delegates network messages to 
    physical connections (using label-matching) by passing them to
    worker-sender threads, which in turn carry out the actual sending.
  * A receiver-scheduler thread, which keeps track of the necessary 
    data structures to buffer IROBs and guarantee that they are passed
    to the application in a correct order.
  * For each physical connection,
    * A sender-worker thread, which sends network messages as directed
      by the sender-scheduler.
    * A receiver-worker thread, which reads messages from the network
      and passes them to the receiver-scheduler.

In order to simplify implementation and thread-safety, interactions between 
the scheduler and worker threads and the application's threads are managed
through thread-safe request queues.  Take for example this sequence of events
that comprise a single send() call on a multi-socket:

1) The application requests bytes be sent on a multi-socket with the FG label. 
   This is accomplished by a library function similar to the send syscall.
2) The library function packages the send() parameters as a request object
   and pushes the request onto the sender-scheduler's queue.
3) When the sender-scheduler thread runs, it pops the request from its queue.
   It then does the necessary bookkeeping for creating a new IROB, adding
   dependency information as needed (see the API documentation on "anonymous"
   IROBs, also called "default" IROBs in the code).  The current implementation
   simply sends IROBs as they arrive; the scheduler could in the future 
   send the IROBs and other requests it receives in any order.
4) The sender-scheduler thread will send a message (an IROB, for instance) by
   choosing a sender-worker thread based on the message's labels and passing
   the message to the sender-worker thread.  As noted above, this is implemented
   via a thread-safe queue in the sender-worker thread.
5) The sender-worker thread wakes up, pops the message from its queue, and
   sends the message on its socket, along with any associated application 
   IROB data.
6) At the remote endpoint, a receiver-worker thread is blocking for input
   on its socket.  When it wakes up from the blocking read, it will read
   the next control message from the network, plus any data that follows.
   It then passes the data as a request message to the receiver-scheduler 
   thread, again via a thread-safe queue.
7) When the remote application calls the recv library function on a 
   multi-socket, it will wait for the next IROB to be released by the
   receiver-scheduler.  (An IROB is released when all of its dependencies
   are satisfied.)  The receiver-scheduler is free to release IROBs in any
   order that obeys the dependencies between them.  The receiver-scheduler
   is also free to release IROBs for which not all the data has arrived yet,
   though it must then release all of that IROB's bytes to the application 
   before it can release another IROB.  Currently, the receiver-scheduler
   will only pass to the application IROBs for which all bytes have arrived.

Aside: if no IROBs can be released to the application, the recv call will by
   default block until the request can be satisfied.  Non-blocking recv is
   feasible, but not yet implemented.

* Connection Scout IPC *

As the connection scout observes networks appearing and disappearing, it sends
updates to all subscriber processes via inter-process message queues.  An IPC
thread in the multi-socket library receives these updates, modifies 
internal data structures to reflect the network status change, and asks the 
CMMSocketSender for each multi-socket to communicate the status change
to the library on the remote host(s).  This thread is also in charge of
firing any queued thunks that were waiting for any now-available interfaces.
