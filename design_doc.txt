Internals of the multi-socket library
-------------------------------------

The multi-socket data structure
-------------------------------

The internal multi-socket data structure has these data elements:
 - An integer socket file descriptor
 - All information needed to create new sockets as needed, including:
   - Parameters for the socket() system call (PF_INET, SOCK_STREAM, etc)
   - All socket options set on this multisocket

 - An internal listener socket and a listener thread that accepts
    new physical connections inside the multi-socket
 - The set of available local network interfaces and their labels
 - The set of available remote network interfaces and their labels
 - The remote multi-socket's internal listener port, for initiating
    new physical connections
 (The above information is exchanged with the initial multi-socket
  post-connection handshake and may be updated later with control
  messages as conditions change on either end.)

 - IROB information for all IROBs in flight but not yet ACK'd,
   including copied data buffers and dependency information
 - A collection of application thread identifiers, indicating
   application threads blocking on sending actions.

 - IROB information for IROBs that have been received by the
   library but not yet passed to the application, including
   copied data buffers and dependency information
 - A collection of "released" IROBs - IROBs that have no unmet
   dependencies and are ready to be passed to the application

 - A CSockMapping structure, which provides an abstract way to
   create and lookup physical connections by label-matching.
   Behind this abstraction, the mapping may change based on 
   updates from the scout, or internally to implement (e.g.) traffic 
   striping and defaulting to the "best" interface if one exists.
 - Each physical connection has these components:
    - A connected socket file descriptor
    - A local/remote interface pair, with associated labels
       - Note to self: this needs to be made more resilient to 
         changing interfaces and labels
    - A sender-scheduler thread, which observes the multi-socket
      state (include changes in IROBs and available interfaces)
      and prepares and sends network messages as the state changes.
    - A receiver-scheduler thread, which receives messages from the
      network, interprets them, and modifies the multi-socket state
      as appropriate (adding/modifying/removing IROBs, changing 
      interface information, etc).

IROB data structures
--------------------

At both the sender and receiver, an IROB contains:
 - An integer ID
 - Send labels and recv labels
 - A collection of dependencies (IROB IDs)
 - A collection of dependents (IROB IDs)
 - A list of data chunks
 - A flag indicating whether the IROB is "default" (no explicit dependencies,
    but depends on all previous IROBs)
 - A flag indicating whether all the application data for this IROB has
    been sent/received

At the sender, IROBs also contain:
 - A thunk handler function and argument, optionally
 - Per-byte and per-IROB acknowledgement status

At the receiver, IROBs also contain:
 - Bookkeeping information about bytes that have been passed to the application

(...under construction...)

Threads and their interactions
------------------------------

On the sender side, application threads call library functions that
modify data structures shared with scheduling threads; when shared
state changes, sender-scheduler threads will wake up, observe the
state change, and potentially construct and send network messages that
communicate the state change - e.g.  a new IROB, a new interface, etc.
On the receiver side, the opposite is true; receiver threads read
messages from the network and update shared state, potentially waking
up application threads that are waiting for new data.  Take for
example this sequence of events that comprise a single send() call on
a multi-socket:

1) The application requests bytes be sent on a multi-socket with the FG label. 
   This is accomplished by a library function similar to the send syscall.
2) The library function calls an internal method of the multi-socket, creating
   a new "default" IROB (one with only implicit dependencies on all in-flight
   IROBs) and adding it to an internal data structure. The application
   thread now sleeps on a condition variable, waiting for the send 
   to complete.
3) The sender-scheduler thread wakes up, notices that there is a new IROB
   that matches its labels, so it packages the IROB as a network message
   and sends it on its socket.  Once the send returns, the sender-scheduler
   signals the application thread that the operation has completed.
4) At the remote endpoint, a receiver-scheduler thread is blocking for input
   on its socket.  When it wakes up from the blocking read, it will read
   the next control message from the network, plus any data that follows.
   It interprets the network message and adds a new IROB to the receiver-side
   data structure, and it also signals any application threads that are blocking
   for incoming data on this multi-socket.
5) When the remote application calls the recv library function on a
   multi-socket, it will wait for the next IROB to be released.  (An
   IROB is released when all of its dependencies are satisfied.)
   IROBs may be received by the application in any order that obeys
   the dependencies between them.  

Aside: if no IROBs can be released to the application, the recv call will by
   default block until the request can be satisfied.  Non-blocking recv is
   feasible, but not yet implemented.

* Connection Scout IPC *

As the connection scout observes networks appearing and disappearing,
it sends updates to all subscriber processes via inter-process message
queues.  An IPC thread in the multi-socket library receives these
updates, modifies internal data structures to reflect the network
status change, and asks each multi-socket to communicate the status
change to the library on the remote host(s).  This thread is also in
charge of firing any queued thunks that were waiting for any
now-available interfaces.
